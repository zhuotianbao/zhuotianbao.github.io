<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[时间戳格式化]]></title>
      <url>%2F2016%2F11%2F27%2F%E6%97%B6%E9%97%B4%E6%88%B3%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
      <content type="text"><![CDATA[要是后端传给我们的是时间戳格式时，我们需要将它转换成我们想要的时间格式来展示。要是我们拿到的是格式化后的时间格式时，当我们想要进行两个时间的对比时，我们需要将格式化后的时间先转换成时间戳才能进行比较。以下是时间戳与格式化时间之间的互相转换: 时间戳转换成格式化的时间 方式一: 12345678910111213141516171819202122 userDate = (uData,form) =&gt; &#123; var myDate = new Date(uData); var year = myDate.getFullYear(); var month = myDate.getMonth() + 1; var day = myDate.getDate(); var hours = myDate.getHours(); var minutes = myDate.getMinutes(); var second = myDate.getSeconds(); //本地当前时间 var curTime = new Date(); var today = curTime.getFullYear()+"-"+(curTime.getMonth()+1)+"-"+curTime.getDate(); if(form=='yy-mm-dd hh:mm')&#123; return year + '-' + month + '-' + day + ' ' + hours + ':' + minutes; &#125;else if(form=='yy-mm-dd hh:mm:ss')&#123; if(today == (year+'-'+month+'-'+day))&#123; return '今天' + ' ' + hours + ':' + minutes + ":" +second; &#125; return year + '-' + month + '-' + day + ' ' + hours + ':' + minutes + ":" +second; &#125; &#125; this.userDate(aaaaaaa,'yy-mm-dd hh:mm:ss');//毫秒数级别 方式二: 1234567891011121314151617181920212223format = (timestamp,format) =&gt; &#123; let newDate = new Date(timestamp); let date = &#123; "M+": this.getMonth() + 1, "d+": this.getDate(), "h+": this.getHours(), "m+": this.getMinutes(), "s+": this.getSeconds(), "q+": Math.floor((this.getMonth() + 3) / 3), "S+": this.getMilliseconds() &#125;; if (/(y+)/i.test(format)) &#123; format = format.replace(RegExp.$1, (this.getFullYear() + '').substr(4 - RegExp.$1.length)); &#125; for (let k in date) &#123; if (new RegExp("(" + k + ")").test(format)) &#123; format = format.replace(RegExp.$1, RegExp.$1.length == 1? date[k] : ("00" + date[k]).substr(("" + date[k]).length)); &#125; &#125; return format;&#125; this.format('1480176000000','yyyy-MM-dd hh:mm:ss');//毫秒数级别 格式化的时间转换成时间戳123456// 获取当前时间戳(**以s为单位**)var date = new Date()var timestamp = Date.parse(date);timestamp = timestamp / 1000;//当前时间戳为：1403149534console.log("当前时间戳为：" + timestamp);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[与更多人分享（被百度收录）]]></title>
      <url>%2F2016%2F11%2F27%2F%E4%B8%8E%E6%9B%B4%E5%A4%9A%E4%BA%BA%E5%88%86%E4%BA%AB%EF%BC%88%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95%EF%BC%89%2F</url>
      <content type="text"><![CDATA[“有个人博客吗？”、“有写博客的习惯吗？”、“有个人博客的优先”…在面试中，最经常遇到的问题。为啥会越来越倡导写博客呢？个人感觉:其一，写博客习惯是个人积累的一种方式（好记性不如烂笔头）；其二，写博客更重在于与他人分享。那么问题来了，github上搭建了自己的博客，网页的链接没有办法被百度蜘蛛爬到，所以网站没有被收录。难道真的只有将自己的博客放在服务器上，才能被百度收录吗？NO，github的服务器在国外，百度没有办法抓取到，但是我们可以把项目备份到coding（国内的，现在已经被收购了gitcafe）上就可以被百度收录了。 啊啊啊啊啊啊啊啊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片上传]]></title>
      <url>%2F2016%2F11%2F21%2F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[上传文件可以有多种方式：（1）将文件读取为二进制编码。（2）将文件读取为文本.（3）将文件读取为DataURL。可以根据项目需要选择不同的文件上传方式。 base64图片上传 HTML5的FileReader对象 方法： 方法名 参数 描述 readAsBinaryString file 将文件读取为二进制编码 readAsText file,[encoding] 将文件读取为文本 readAsDataURL file 将文件读取为DataURL abort (none) 终端读取操作 接口事件： 事件 描述 onabort 中断 onerror 出错 onloadstart 开始 onprogress 正在读取 onload 成功读取 onloadend 读取完成，无论成功失败 代码 1234567891011121314151617181920212223242526272829&lt;img id="ImgPr" src=""/&gt; &lt;input type="file" class="" id="inputFile" &gt;function readAsDataURL(m_this,id)&#123; if (typeof m_this.files == 'undefined' || typeof FileReader == 'undefined') &#123; alert('当前浏览器不支持图片上传，请改用IE10以上或chrome等最新浏览器。'); return false; &#125; if(!/image\/\w+/.test(m_this.files[0].type))&#123; alert("请上传图片！"); return false; &#125; var reader = new FileReader(); reader.onload = function(e) &#123; //this.result 返回结果 $(id).attr('src',this.result); //把结果放在img对象中，以备他用 var img = new Image(); img.src = result; &#125; reader.readAsDataURL(m_this.files[0]); &#125;//调用$('#inputFile').on('change',function()&#123; var m_this = this; readAsDataURL(m_this,'#ImgPr'); &#125;) HTML5 本地裁剪图片并上传至服务器（老梗） 参考链接：https://segmentfault.com/a/1190000000754560#articleHeader0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS样式笔记]]></title>
      <url>%2F2016%2F11%2F21%2FCSS%E6%A0%B7%E5%BC%8F%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[select设置右对齐123select &#123; direction: rtl;&#125; 触发点击事件时，响应的背景框的颜色 -webkit-tap-highlight-color -webkit-tap-highlight-color: rgba(240,240,240,0.7);则可改变元素被点击时背景框的颜色 如果需要背景框不显示，则可以将rgba中的alpha值设为0即可，例如rgba(0,0,0,0) marquee标签实现的跑马灯 不能设置overflow: hidden;样式，否则marquee标签不起作用 css 只能显示两行 超过显示点点点 样式一： 1234567891011.p1&#123;text-align: center;color:#C8CFD6;height:34px;text-overflow: -o-ellipsis-lastline;overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical;&#125; 样式二： 123max-height:40px;line-height:20px;overflow:hidden; 让一张图片居中显示 将图片设置成背景图:background-image:url(....) 设置属性:background-size:cover 设置css3中placeholder的字体颜色 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素 css伪类：CSS 伪类用于向某些选择器添加特殊的效果 css伪元素：CSS 伪元素用于向某些选择器设置特殊效果123456789101112input::-webkit-input-placeholder, textarea::-webkit-input-placeholder &#123; color: #666;&#125;input:-moz-placeholder, textarea:-moz-placeholder &#123; color:#666;&#125;input::-moz-placeholder, textarea::-moz-placeholder &#123; color:#666;&#125;input:-ms-input-placeholder, textarea:-ms-input-placeholder &#123; color:#666;&#125; 多选框动画样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657HTML:&lt;div className="detailReason" &gt; &lt;input type="checkbox" id="1" value="广告"/&gt; &lt;label htmlFor="1"&gt;广告&lt;/label&gt;&lt;/div&gt;&lt;div className="detailReason" &gt; &lt;input type="checkbox" id="2" value="老旧重复"/&gt; &lt;label htmlFor="2"&gt;老旧重复&lt;/label&gt;&lt;/div&gt;CSS:label&#123; width: 100%; position: relative; font-size:16px; color:#222; display: block;&#125;label:before&#123; width: 14px; height: 14px; content: ''; border: 1px solid #ddd; border-radius: 50%; display: inline-block; vertical-align: middle; margin-right: 10px;&#125;[type="checkbox"]&#123; display: none;&#125;label:after&#123; width: 6px; height: 6px; content: ''; background-color: #00aaee; border-radius: 50%; display: inline-block; vertical-align: middle; margin-right: 10px; transform:scale(0); -webkit-transform:scale(0); transition: transform .2s ease-out; -webkit-transition: transform .2s ease-out; position: absolute; top: 20px; left: 5px;&#125;[type="checkbox"]:checked + label:before&#123; border: 1px solid #00aaee;&#125;[type="checkbox"]:checked + label:after&#123; transform:scale(1); -webkit-transform:scale(1); transition: transform .2s ease-out; -webkit-transition: transform .2s ease-in;&#125; 单选框动画样式123456789101112HTML:&lt;div className="detailReason" &gt; &lt;input type="checkbox" name="radio" id="1" value="广告"/&gt; &lt;label htmlFor="1"&gt;广告&lt;/label&gt;&lt;/div&gt;&lt;div className="detailReason" &gt; &lt;input type="checkbox" name="radio" id="2" value="老旧重复"/&gt; &lt;label htmlFor="2"&gt;老旧重复&lt;/label&gt;&lt;/div&gt;CSS:样式和上面多选框的样式一样 UC浏览器——css3的坑最近在做一个移动端项目，涉及到评论模块，有评论必有点赞功能，当然也就存在点赞动画效果，第一反应就是利用css3动画效果。 方案一:transition+伪元素 。方案二:transition。方案呢三:animation+伪元素。方案呢四:animation。 背景:项目最终是放在支付宝平台上的，而支付宝用的是UC内核。 在chrome、qq、微信等等打开都是没问题（perfect，以为大功告成了…），谁知最后在支付宝（uc内核）打开…方案一/方案二/方案三都是一点效果都没有（这是针对安卓手机没效果，对于IOS效果还是有的，可见乔布斯的强大啊）…呜呜呜…天啊，这是咋回事呢？ 总结:在UC浏览器中，不支持伪元素使用css3动画，对于transition动画也不佳。提倡使用方案四…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[跨域解决方案]]></title>
      <url>%2F2016%2F11%2F19%2F%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。所谓同源是指，域名，协议，端口均相同。 JSONP 本质上是利用 &lt;script&gt; 标签的跨域能力实现跨域数据的访问，请求动态生成的JavaScript脚本同时带一个callback函数名作为参数 只能以GET请求方式 浏览器端构造请求地址 1234567function resolveJson(result) &#123; console.log(result.name);&#125;var jsonpScript= document.createElement("script");jsonpScript.type = "text/javascript";jsonpScript.src = "http://www.qiute.com?callbackName=resolveJson";document.getElementsByTagName("head")[0].appendChild(jsonpScript); resolveJson 是我们默认注册的回调函数，注意，该函数名需要全局唯一 友情提示: （掉坑的经验） 用jsonp请求相当于script标签的请求，因此很有可能会走缓存（移动端经常出现），因此可以在每个请求路径后面加上一个随机数让它不走缓存 jsonp请求只能是GET请求方式，当你设置为POST请求方式时，它会自动转成GET方式去请求 当你写POST请求方式的jsonp时，在打包压缩会出异常，会出现data请求主体的数据没被带上。解决方案：其一，将POST改为GET，data主体数据不变；其二，将POST改为GET，并且把data主体数据拼接到URL后面 CORS:跨域资源共享 不同于JSONP，CORS是以Ajax方式进行跨域请求，需要服务端与客户端的同时支持。 分为 简单请求 和 预检请求 两大类 以下的解决方案可以是使用正常的请求，又不需要后端更改代码，依然可以正常跨域请求的 用Nginx实现简单的前后端分离 首先建议在Mac中安装brew，以后装什么都方便。在命令行中复制如下代码即可：/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;。 执行 brew search nginx brew install nginx 。 启动nginx ，sudo nginx;访问localhost:8080 发现已出现nginx的欢迎页面了。 配置nginx,在Mac的根目录下，cd usr/local/etc/nginx、vim nginx.conf ，进入编辑nginx.conf，在server的配置中加入以下代码(删掉注释)。保存退出后不要忘了重启Nginx，nginx -s reload,然后就可以愉快的联调了。 1234567891011//文件后缀可以根据实际需要添加，基本都是静态文件location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css|html)$ &#123; //你本地的node服务（即webpack的daServer）IP proxy_pass http://192.168.2.72:8888; proxy_buffering off;&#125;location ~ /admin/api/ &#123; //后端童鞋的服务器IP proxy_pass http://192.168.2.96:8080;&#125;//这个方法感觉每次和一个人调都要去更改那个配置，挺麻烦的 再后来，又发现了一个比用nginx更加方便的方法，那就是用webpack配置中devServer自带的proxy代理功能 Proxy:服务端跨域 使用代理方式跨域更加直接，因为SOP的限制是浏览器实现的。如果请求不是从浏览器发起的，就不存在跨域问题了 使用本方法跨域步骤如下： 把访问其它域的请求替换为本域的请求 本域的请求是服务器端的动态脚本负责转发实际的请求 1234567891011121314151617// 配置服务器 devServer: &#123; historyApiFallback: true, hot: true, inline: true, progress: true, contentBase: "./app", //最好写上，否则报错，难道这里是一个坑？ port: 9999, proxy: &#123; '/activity/*':&#123; changeOrigin: true, target: 'https://118.178.109.73', secure: false, &#125; &#125; &#125;//我可以把所有人的接口一次性配置好，这个代理方法是不是更加简单粗暴呢~~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github搭建个人博客]]></title>
      <url>%2F2016%2F11%2F17%2Fgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[绪：想做个个人博客已经许久了，常常这的那的导致始终都没能真正抽点时间去搭建下博客。这几天突然又想起这事，便趁工作之余寻思了起来。以下是我博客的搭建过程，以及搭建过程中遇到的问题。 第一部分：hexo的配置 下载安装Nodejs 使用npm安装hexo npm install -g hexo 建立Blog的文件夹，并初始化hexo mkdir Blog hexo init 安装依赖 npm install hexo的配置已经基本完成,启动本地服务 hexo server(hexo默认的端口号是4000) hexo server -p 8081(改端口号8081) 在github上新建一个repository保存Blog的页面 需要注意的是repository 的name有个特别的限定，就是你的github的username.github.io（zhuotianbao.github.io） 修改配置文件(_config.yml) 1234deploy: type: git repository: https://github.com/zhuotianbao/zhuotianbao.github.io.git branch: master 将Blog部署到Github hexo generate(修改过_config.yml或者文章后都要记得执行下该命令) hexo deploy(将Blog的内容推送到Githu) 访问https://zhuotianbao.github.io/就可以查看你的Blog内容了 hexo主题的使用: git clone https://github.com/iissnan/hexo-theme-next themes/next 修改_config.yml的theme项为yilia就可以了 添加新文章 hexo new articlename(会在source/_posts/articlename.md，编辑该md文件后) hexo generate 和hexo deploy就可以在github上看到你的新文章 第二部分：Github SSH Key配置(在推送文章到Github时，使用ssh进行验证可以免于输入账户和密码) 配置用户名和邮箱 12git config user.name "username"git config user.email "email" ssh-keygen -t rsa -b 4096 -C &quot;your email&quot;生成公钥和私钥，运行该命令后会有提示的输入信息，可以直接回车跳过。 添加私钥到ssh。这时有可能ssh-agent没有启动，可以现在Git Bash中运行命令eval &quot;$(ssh-agent -s)来启动，然后运行ssh-add 私钥名称添加私钥。（默认的私钥名称是rsa，如果在生成私钥时设定了名称，就输入上次设定的名称） 添加公钥到Github的账号。首先使用命令clip &lt; rsa.pub 将公钥的内容复制到剪贴板，然后登录Github，选择settings &gt; SSH Keys &gt; New SSH Key ，将公钥内容粘贴过去，点击 Add New SSH即可。 验证ssh的配置是否成功。上述步骤完成后，在Git Bash中运行命令ssh git@github.com，根据提示信息判断ssh的配置是否成功。 第三部分：部分问题可参看：https://hexo.io/docs/troubleshooting.html node-sass编译报错： 123In file included from ../src/binding.cpp:3:../src/sass_context_wrapper.h:8:10: fatal error: 'sass/context.h' file not found#include &lt;sass/context.h&gt; 123解决方案：brew install libsass 在执行 hexo deploy 后,出现 error deployer not found:git 的错误 12解决方案：npm install hexo-deployer-git --save 第四部分：主题的选择在主题的选择很纠结了很久，有next,casper,landscape,yilia……但最后比较合胃口的是next和yilia，在这两者之间也决定了很久，最终敲定next主题。 下载next主题:git clone https://github.com/iissnan/hexo-theme-next themes/next next主题官网:http://theme-next.iissnan.com/ next主题配置:http://theme-next.iissnan.com/theme-settings.html 安装多说评论 登录多说创建站点 填写完信息后，点击创建，生成代码 1231、data-thread-key 我改为[[ site.url ]]_[[ page.title ]] 2、data-title 我改为[[ page.title ]] 3、data-url 我改为[[ site.url ]] 将代码粘贴到next主题下的:themes/next/layout/_partials/comments.swig文件下 最后在next主题配置文件:themes/next/_config.yml文件下修改duoshuo_shortname:galengao（这个是创建多说站点中那个多说域名值）]]></content>
    </entry>

    
  
  
</search>
